<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>Miami Prototype — GTA-style dual POV</title>
<style>
  :root {
    color-scheme: dark;
  }
  html,body {
    height:100%;
    margin:0;
    background:linear-gradient(#07121f,#1b0f1f);
    overflow:hidden;
    font-family: "Segoe UI", Roboto, Arial, sans-serif;
  }
  * {
    box-sizing:border-box;
  }
  #gameRoot {
    width:100vw;
    height:100vh;
    display:flex;
    align-items:flex-start;
    justify-content:center;
    position:relative;
    padding:0;
  }
  canvas {
    box-shadow:0 18px 60px rgba(0,0,0,0.65);
    border-radius:12px;
    background:#6ec3ff;
    width:1200px;
    height:700px;
    max-width:calc(100vw - 40px);
    max-height:calc(100vh - 40px);
    image-rendering:pixelated;
    touch-action:none;
    border:1px solid rgba(255,255,255,0.08);
  }
  #ui {
    position:absolute;
    left:20px;
    top:16px;
    color:#fff;
    text-shadow:0 1px 3px rgba(0,0,0,0.7);
    display:flex;
    flex-direction:column;
    gap:6px;
  }
  .badge {
    background:rgba(0,0,0,0.35);
    padding:6px 12px;
    border-radius:999px;
    font-size:13px;
    display:inline-flex;
    align-items:center;
  }
  #hint {
    position:absolute;
    right:20px;
    top:16px;
    max-width:360px;
    color:#fff;
    text-align:right;
    text-shadow:0 1px 2px rgba(0,0,0,0.75);
    font-size:13px;
  }
  #controls {
    position:absolute;
    left:20px;
    bottom:18px;
    color:#fff;
    font-size:13px;
    display:flex;
    gap:12px;
    align-items:center;
  }
  #controls .toggle {
    background:rgba(255,255,255,0.12);
    padding:6px 14px;
    border-radius:999px;
    cursor:pointer;
    transition:background 0.15s;
  }
  #controls .toggle:hover {
    background:rgba(255,255,255,0.22);
  }
  #fps {
    position:absolute;
    right:20px;
    bottom:18px;
    color:#fff;
    font-size:13px;
    text-shadow:0 1px 2px rgba(0,0,0,0.7);
  }
  #enterHouse {
    position:absolute;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
    background:rgba(255,255,255,0.97);
    color:#111;
    padding:22px 28px;
    border-radius:10px;
    box-shadow:0 18px 50px rgba(0,0,0,0.5);
    width:420px;
    display:none;
  }
  #enterHouse h3 {
    margin:0 0 12px 0;
    font-size:20px;
    letter-spacing:0.02em;
  }
  #enterHouse button {
    border:none;
    background:#2573ff;
    color:#fff;
    border-radius:6px;
    padding:8px 16px;
    cursor:pointer;
    font-weight:600;
  }
  #pointerHint {
    position:absolute;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
    background:rgba(0,0,0,0.72);
    color:#fff;
    padding:18px 26px;
    border-radius:10px;
    font-size:14px;
    text-align:center;
    box-shadow:0 12px 40px rgba(0,0,0,0.55);
    display:none;
    max-width:320px;
    line-height:1.4;
  }
  @media (max-width:780px) {
    #hint { display:none; }
    #controls { flex-direction:column; align-items:flex-start; }
  }
</style>
</head>
<body>
<div id="gameRoot">
  <canvas id="gameCanvas" width="1200" height="700"></canvas>

  <div id="ui">
    <div class="badge" id="title">miami sandbox prototype</div>
    <div class="badge" id="mode">view: 3rd person</div>
  </div>

  <div id="hint">
    <div class="badge">wasd / arrows: move · e: enter / exit · c: switch pov · click canvas (1st-person) for mouse-look · [ / ] rotate without mouse · xbox controller supported</div>
  </div>

  <div id="controls">
    <span class="badge">engine: vanilla js + canvas</span>
    <span class="toggle" id="resetBtn">reset world</span>
  </div>

  <div id="fps"></div>

  <div id="enterHouse">
    <h3>House Interior</h3>
    <p>Lightweight placeholder interior. Press <strong>E</strong> or use the button to exit.</p>
    <div style="text-align:right;margin-top:16px;">
      <button id="closeHouse">Exit</button>
    </div>
  </div>

  <div id="pointerHint">
    First-person mouse-look is off.<br>Click once inside the scene to lock the cursor.<br><span style="font-size:12px;opacity:0.8;">(Press Esc to release · use [ and ] to rotate if you prefer keyboard)</span>
  </div>
</div>

<script>
/* ------------------------------------------------------------------
   gta-inspired miami prototype (single script)
   - single canvas, fixed viewport, responsive scaling (no scrolling)
   - player movement, cars (drive & exit), house interiors
   - third-person top-down + true first-person projection
   - xbox controller support via Gamepad API
   - pointer lock mouse-look with keyboard/gamepad fallback
------------------------------------------------------------------- */

/* -----------------------
   canvas & ui references
----------------------- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha:false });
const width = canvas.width;
const height = canvas.height;

const uiMode = document.getElementById('mode');
const fpsLabel = document.getElementById('fps');
const resetBtn = document.getElementById('resetBtn');
const enterHouseDiv = document.getElementById('enterHouse');
const closeHouseBtn = document.getElementById('closeHouse');
const pointerHint = document.getElementById('pointerHint');

/* -----------------------
   world state
----------------------- */
const world = {
  mapSize: { w: 3200, h: 2000 },
  player: null,
  cars: [],
  buildings: [],
  decor: [],
  roads: [],
  camera: { x:0, y:0, zoom:1 }
};

/* -----------------------
   utility helpers
----------------------- */
const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
const len = (x, y) => Math.hypot(x, y);
const toRad = deg => deg * Math.PI / 180;

/* -----------------------
   player & car classes
----------------------- */
class Player {
  constructor(x,y){
    this.x = x;
    this.y = y;
    this.angle = 0;
    this.heading = toRad(90); // default facing south
    this.walkSpeed = 260;
    this.radius = 14;
    this.inCar = null;
    this.currentSpeed = 0;
    this.eyeHeight = 64;
  }
  update(dt, input, viewMode){
    if (this.inCar){
      this.x = this.inCar.x;
      this.y = this.inCar.y;
      this.heading = this.inCar.angle;
      this.angle = this.inCar.angle;
      this.currentSpeed = 0;
      return;
    }

    if (viewMode === 'first'){
      const mouseYaw = input.lookDeltaX * 0.0025;
      const analogYaw = input.lookAnalog * 1.6 * dt;
      const keyYaw = ((input.turnKeyRight?1:0) - (input.turnKeyLeft?1:0)) * 1.9 * dt;
      this.heading += mouseYaw + analogYaw + keyYaw;
      this.angle = this.heading;
      input.lookDeltaX = 0;

      const forward = { x: Math.cos(this.heading), y: Math.sin(this.heading) };
      const right = { x: Math.cos(this.heading + Math.PI/2), y: Math.sin(this.heading + Math.PI/2) };
      let moveX = 0, moveY = 0;
      if (input.moveForward) { moveX += forward.x; moveY += forward.y; }
      if (input.moveBackward) { moveX -= forward.x; moveY -= forward.y; }
      if (input.moveLeft) { moveX -= right.x; moveY -= right.y; }
      if (input.moveRight) { moveX += right.x; moveY += right.y; }

      const mag = len(moveX, moveY);
      if (mag > 0){
        const normX = moveX / mag;
        const normY = moveY / mag;
        const appliedSpeed = this.walkSpeed * Math.min(1, mag);
        this.x += normX * appliedSpeed * dt;
        this.y += normY * appliedSpeed * dt;
        this.currentSpeed = appliedSpeed;
      } else {
        this.currentSpeed = 0;
      }
    } else {
      let vx = (input.moveRight?1:0) - (input.moveLeft?1:0);
      let vy = (input.moveBackward?1:0) - (input.moveForward?1:0);
      const mag = len(vx, vy);
      if (mag > 0){
        vx /= mag;
        vy /= mag;
        this.x += vx * this.walkSpeed * dt;
        this.y += vy * this.walkSpeed * dt;
        this.angle = Math.atan2(vy, vx);
        this.heading = this.angle;
        this.currentSpeed = this.walkSpeed;
      } else {
        this.currentSpeed = 0;
      }
    }

    this.x = clamp(this.x, 20, world.mapSize.w - 20);
    this.y = clamp(this.y, 20, world.mapSize.h - 20);
  }
  draw(ctx, cam, viewMode){
    if (viewMode === 'first') return;
    const screen = worldToScreen(this.x, this.y, cam);
    ctx.save();
    ctx.translate(screen.x, screen.y);
    ctx.fillStyle = '#ffd966';
    ctx.beginPath();
    ctx.arc(0,0,this.radius,0,Math.PI*2);
    ctx.fill();
    ctx.rotate(this.angle);
    ctx.fillStyle = '#222';
    ctx.fillRect(0,-4,this.radius+10,8);
    ctx.restore();
  }
}

class Car {
  constructor(x,y,color='#ff5d73'){
    this.x = x;
    this.y = y;
    this.w = 48;
    this.h = 28;
    this.color = color;
    this.angle = 0;
    this.speed = 0;
    this.maxSpeed = 480;
    this.accel = 820;
    this.brake = 1200;
    this.turnSpeed = 2.6;
    this.friction = 0.9;
    this.driver = null;
  }
  update(dt, input){
    if (this.driver){
      const forwardInput = clamp(-input.axisY, -1, 1);
      if (forwardInput > 0){
        this.speed += this.accel * forwardInput * dt;
      } else if (forwardInput < 0){
        this.speed += this.brake * forwardInput * dt; // backward (negative)
      } else {
        this.speed *= Math.pow(this.friction, dt*60);
        if (Math.abs(this.speed) < 4) this.speed = 0;
      }
      this.speed = clamp(this.speed, -this.maxSpeed*0.45, this.maxSpeed);

      const steerInput = clamp(input.axisX, -1, 1);
      const speedFactor = Math.min(1, Math.abs(this.speed) / this.maxSpeed);
      this.angle += steerInput * this.turnSpeed * speedFactor * dt;

      this.x += Math.cos(this.angle) * this.speed * dt;
      this.y += Math.sin(this.angle) * this.speed * dt;
    } else {
      this.speed *= Math.pow(this.friction, dt*60);
      if (Math.abs(this.speed) < 2) this.speed = 0;
    }

    this.x = clamp(this.x, 30, world.mapSize.w - 30);
    this.y = clamp(this.y, 30, world.mapSize.h - 30);
  }
  draw(ctx, cam, viewMode){
    if (viewMode === 'first') return;
    const s = worldToScreen(this.x, this.y, cam);
    ctx.save();
    ctx.translate(s.x, s.y);
    ctx.rotate(this.angle);
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.beginPath();
    ctx.ellipse(4, 10, this.w*0.32, this.h*0.25, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = this.color;
    ctx.fillRect(-this.w/2, -this.h/2, this.w, this.h);
    ctx.fillStyle = 'rgba(255,255,255,0.7)';
    ctx.fillRect(-this.w/4, -this.h/4, this.w/2, this.h/2);
    ctx.fillStyle = '#111';
    ctx.fillRect(-this.w/2+4, this.h/2-6, 12, 6);
    ctx.fillRect(this.w/2-16, this.h/2-6, 12, 6);
    ctx.restore();
  }
}

/* -----------------------
   world generation
----------------------- */
function createDemoWorld(){
  world.buildings = [];
  world.cars = [];
  world.decor = [];
  world.roads = [
    { x: 0, y: 520, w: world.mapSize.w, h: 210 },
    { x: 0, y: 1100, w: world.mapSize.w, h: 220 },
    { x: 980, y: 0, w: 240, h: world.mapSize.h }
  ];

  world.player = new Player(world.mapSize.w * 0.35, world.mapSize.h * 0.62);

  const palettes = [
    ['#ffe3ef', '#ff9dd7'],
    ['#fbeacc', '#ffb870'],
    ['#cff3f9', '#5dd0ff'],
    ['#f4d0ff', '#d28bff']
  ];

  let id = 0;
  for (let r=0; r<3; r++){
    for (let c=0; c<5; c++){
      const bx = 360 + c*420 + (r%2)*60;
      const by = 260 + r*420;
      const bw = 260;
      const bh = 160;
      const palette = palettes[(r+c)%palettes.length];
      const windows = [];
      for (let rx=14; rx<bw-20; rx+=46){
        for (let ry=12; ry<bh-22; ry+=34){
          windows.push({ x: rx, y: ry, color: Math.random()>0.6 ? '#ffeebb' : '#9fffe0' });
        }
      }
      world.buildings.push({
        id:id++,
        x: bx,
        y: by,
        w: bw,
        h: bh,
        color: palette[0],
        roof: palette[1],
        door: { x: bx + bw - 28, y: by + bh/2 + 10 },
        windows
      });
    }
  }

  world.cars.push(new Car(1180, 760, '#ff5d73'));
  world.cars.push(new Car(980, 980, '#66ffb2'));
  world.cars.push(new Car(1450, 1200, '#ffd66b'));
  world.cars.push(new Car(1850, 640, '#5dd0ff'));

  for (let i=0;i<20;i++){
    world.decor.push({
      x: 200 + Math.random() * (world.mapSize.w - 400),
      y: 200 + Math.random() * (world.mapSize.h - 400),
      height: 110 + Math.random()*60
    });
  }

  world.camera.x = world.player.x;
  world.camera.y = world.player.y;
}

/* -----------------------
   input handling
----------------------- */
const keyState = {
  forward:false, backward:false, left:false, right:false,
  interact:false, toggleView:false,
  turnLeft:false, turnRight:false
};
const padState = {
  axisX:0, axisY:0, lookX:0,
  forward:false, backward:false, left:false, right:false,
  interact:false, toggleView:false
};
const input = {
  moveForward:false, moveBackward:false, moveLeft:false, moveRight:false,
  axisX:0, axisY:0,
  interact:false,
  toggleView:false,
  lookDeltaX:0,
  lookAnalog:0,
  turnKeyLeft:false,
  turnKeyRight:false,
  pointerLocked:false
};

function setKeyState(key, value){
  switch (key){
    case 'w': case 'arrowup': keyState.forward = value; break;
    case 's': case 'arrowdown': keyState.backward = value; break;
    case 'a': keyState.left = value; break;
    case 'd': keyState.right = value; break;
    case 'arrowleft': keyState.left = value; keyState.turnLeft = value; break;
    case 'arrowright': keyState.right = value; keyState.turnRight = value; break;
    case 'e': keyState.interact = value; break;
    case 'c': if (value) keyState.toggleView = true; break;
    case '[': keyState.turnLeft = value; break;
    case ']': keyState.turnRight = value; break;
  }
}
window.addEventListener('keydown', e => {
  if (e.repeat) return;
  setKeyState(e.key.toLowerCase(), true);
  if (e.key.toLowerCase() === 'r') resetWorld();
});
window.addEventListener('keyup', e => {
  setKeyState(e.key.toLowerCase(), false);
});

function composeInput(){
  input.moveForward = keyState.forward || padState.forward;
  input.moveBackward = keyState.backward || padState.backward;
  input.moveLeft = keyState.left || padState.left;
  input.moveRight = keyState.right || padState.right;

  const keyAxisX = (keyState.right?1:0) - (keyState.left?1:0);
  const keyAxisY = (keyState.backward?1:0) - (keyState.forward?1:0);
  input.axisX = clamp(keyAxisX + padState.axisX, -1, 1);
  input.axisY = clamp(keyAxisY + padState.axisY, -1, 1);

  input.interact = keyState.interact || padState.interact;
  input.lookAnalog = padState.lookX;
  input.turnKeyLeft = keyState.turnLeft;
  input.turnKeyRight = keyState.turnRight;

  input.toggleView = keyState.toggleView || padState.toggleView;
  keyState.toggleView = false;
  padState.toggleView = false;
}

let prevPadButtons = { A:false, B:false };
function pollGamepad(){
  const gamepads = navigator.getGamepads ? navigator.getGamepads() : null;
  const g = gamepads ? gamepads[0] : null;
  if (!g){
    padState.axisX = padState.axisY = padState.lookX = 0;
    padState.forward = padState.backward = padState.left = padState.right = false;
    padState.interact = false;
    return;
  }
  const dead = 0.2;
  const lx = Math.abs(g.axes[0]) > dead ? g.axes[0] : 0;
  const ly = Math.abs(g.axes[1]) > dead ? g.axes[1] : 0;
  const rx = Math.abs(g.axes[2]) > dead ? g.axes[2] : 0;
  padState.axisX = lx;
  padState.axisY = ly;
  padState.lookX = rx;
  padState.forward = ly < -dead;
  padState.backward = ly > dead;
  padState.left = lx < -dead;
  padState.right = lx > dead;
  padState.interact = !!(g.buttons[0] && g.buttons[0].pressed);
  if (g.buttons[1] && g.buttons[1].pressed && !prevPadButtons.B){
    padState.toggleView = true;
  }
  prevPadButtons.A = !!(g.buttons[0] && g.buttons[0].pressed);
  prevPadButtons.B = !!(g.buttons[1] && g.buttons[1].pressed);
}

/* pointer lock for first-person look */
canvas.addEventListener('click', () => {
  if (viewMode === 'first' && !input.pointerLocked){
    canvas.requestPointerLock();
  }
});
document.addEventListener('pointerlockchange', () => {
  input.pointerLocked = document.pointerLockElement === canvas;
  updatePointerHint();
});
document.addEventListener('mousemove', e => {
  if (!input.pointerLocked) return;
  input.lookDeltaX += e.movementX;
});

/* -----------------------
   coordinate helpers
----------------------- */
function worldToScreen(wx, wy, cam){
  const sx = (wx - cam.x) + width/2;
  const sy = (wy - cam.y) + height/2;
  return { x:sx, y:sy };
}
function screenRectFromWorld(rect, cam){
  const topLeft = worldToScreen(rect.x, rect.y, cam);
  const bottomRight = worldToScreen(rect.x + rect.w, rect.y + rect.h, cam);
  return { x:topLeft.x, y:topLeft.y, w:bottomRight.x - topLeft.x, h:bottomRight.y - topLeft.y };
}
function toCameraSpace(wx, wy, origin, heading){
  const dx = wx - origin.x;
  const dy = wy - origin.y;
  const cos = Math.cos(heading);
  const sin = Math.sin(heading);
  const forward = dx * cos + dy * sin;
  const side = -dx * sin + dy * cos;
  return { forward, side };
}

/* -----------------------
   interactions
----------------------- */
function tryEnterExit(){
  if (enterHouseDiv.style.display === 'block'){
    closeHouse();
    return;
  }
  if (world.player.inCar){
    const car = world.player.inCar;
    const exitX = car.x + Math.cos(car.angle) * (car.w + 30);
    const exitY = car.y + Math.sin(car.angle) * (car.w + 30);
    car.driver = null;
    world.player.inCar = null;
    world.player.x = clamp(exitX, 30, world.mapSize.w - 30);
    world.player.y = clamp(exitY, 30, world.mapSize.h - 30);
    return;
  }
  for (const car of world.cars){
    if (len(world.player.x - car.x, world.player.y - car.y) < 60){
      car.driver = world.player;
      world.player.inCar = car;
      world.player.heading = car.angle;
      return;
    }
  }
  for (const b of world.buildings){
    const d = b.door;
    if (len(world.player.x - d.x, world.player.y - d.y) < 48){
      openHouse(b);
      return;
    }
  }
}
function openHouse(b){
  if (document.pointerLockElement === canvas) document.exitPointerLock();
  enterHouseDiv.style.display = 'block';
  enterHouseDiv.querySelector('h3').textContent = `Interior — Casa ${b.id+1}`;
}
function closeHouse(){
  enterHouseDiv.style.display = 'none';
}

/* -----------------------
   camera handling
----------------------- */
function updateCamera(dt){
  const target = world.player.inCar ? world.player.inCar : world.player;
  world.camera.x += (target.x - world.camera.x) * clamp(6*dt, 0, 1);
  world.camera.y += (target.y - world.camera.y) * clamp(6*dt, 0, 1);
}

/* -----------------------
   rendering pipeline
----------------------- */
function renderScene(){
  if (viewMode === 'third'){
    renderThirdPerson();
  } else {
    renderFirstPerson();
  }
  drawMinimap();
}

function renderThirdPerson(){
  ctx.fillStyle = '#88d9ff';
  ctx.fillRect(0,0,width,height);
  drawBackground();
  drawGround(world.camera);
  drawBuildings(world.camera);
  drawDecorTop(world.camera);
  for (const car of world.cars) car.draw(ctx, world.camera, viewMode);
  world.player.draw(ctx, world.camera, viewMode);
}

function drawBackground(){
  const grad = ctx.createLinearGradient(0,0,0,height*0.5);
  grad.addColorStop(0,'#fdf0ff');
  grad.addColorStop(0.6,'#ffc6e7');
  grad.addColorStop(1,'#8ec5ff');
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,width,height*0.5);
  ctx.fillStyle = '#fff2b2';
  ctx.beginPath();
  ctx.arc(width - 120, 90, 42, 0, Math.PI*2);
  ctx.fill();
}

function drawGround(cam){
  ctx.fillStyle = '#f7e6d2';
  ctx.fillRect(0,0,width,height);

  for (const road of world.roads){
    const rect = screenRectFromWorld(road, cam);
    ctx.save();
    ctx.fillStyle = '#2e2e33';
    ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
    ctx.strokeStyle = 'rgba(255,255,255,0.3)';
    ctx.lineWidth = 2;
    ctx.setLineDash([14,18]);
    ctx.beginPath();
    if (road.w > road.h){
      ctx.moveTo(rect.x, rect.y + rect.h/2);
      ctx.lineTo(rect.x + rect.w, rect.y + rect.h/2);
    } else {
      ctx.moveTo(rect.x + rect.w/2, rect.y);
      ctx.lineTo(rect.x + rect.w/2, rect.y + rect.h);
    }
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();
  }
}

function drawBuildings(cam){
  for (const b of world.buildings){
    const rect = screenRectFromWorld(b, cam);
    ctx.save();
    ctx.translate(rect.x, rect.y);
    ctx.fillStyle = b.color;
    ctx.fillRect(0, 0, rect.w, rect.h);
    ctx.fillStyle = b.roof;
    ctx.fillRect(0, -10, rect.w, 10);
    for (const w of b.windows){
      const wx = (w.x / b.w) * rect.w;
      const wy = (w.y / b.h) * rect.h;
      ctx.fillStyle = w.color;
      ctx.fillRect(wx, wy, rect.w * 0.1, rect.h * 0.12);
    }
    const doorX = (b.door.x - b.x) / b.w * rect.w;
    const doorY = (b.door.y - b.y) / b.h * rect.h;
    ctx.fillStyle = '#1c1c1c';
    ctx.fillRect(doorX - 14, doorY - 32, 28, 40);
    ctx.restore();
  }
}

function drawDecorTop(cam){
  ctx.fillStyle = '#22765c';
  for (const palm of world.decor){
    const base = worldToScreen(palm.x, palm.y, cam);
    ctx.fillRect(base.x-2, base.y-40, 4, 40);
    for (let i=0;i<4;i++){
      ctx.beginPath();
      ctx.ellipse(base.x + Math.sin(i)*12, base.y-44 - i*6, 18 - i*2, 8, Math.sin(i)*0.4, 0, Math.PI*2);
      ctx.fill();
    }
  }
}

/* -----------------------
   first-person rendering
----------------------- */
function renderFirstPerson(){
  const viewer = world.player.inCar ? world.player.inCar : world.player;
  const heading = world.player.inCar ? world.player.inCar.angle : world.player.heading;
  const origin = { x: viewer.x, y: viewer.y };
  const horizon = height * 0.42;
  const groundY = height * 0.92;
  const focal = 640;

  ctx.fillStyle = '#10142b';
  ctx.fillRect(0,0,width,height);

  drawFirstPersonSky(horizon);
  drawFirstPersonGround(horizon, groundY);

  const entities = [];

  for (const b of world.buildings){
    const centerX = b.x + b.w/2;
    const centerY = b.y + b.h/2;
    const cam = toCameraSpace(centerX, centerY, origin, heading);
    if (cam.forward <= 30 || cam.forward > 2200) continue;
    entities.push({
      type:'building',
      forward: cam.forward,
      side: cam.side,
      width: b.w,
      height: 240,
      baseColor: b.color,
      accent: b.roof
    });
  }

  for (const decor of world.decor){
    const cam = toCameraSpace(decor.x, decor.y, origin, heading);
    if (cam.forward <= 20 || cam.forward > 1500) continue;
    entities.push({
      type:'palm',
      forward: cam.forward,
      side: cam.side,
      width: 40,
      height: decor.height
    });
  }

  for (const car of world.cars){
    const cam = toCameraSpace(car.x, car.y, origin, heading);
    if (cam.forward <= 20 || cam.forward > 1800) continue;
    entities.push({
      type:'car',
      forward: cam.forward,
      side: cam.side,
      width: car.w,
      height: 50,
      color: car.color,
      isPlayer: car === world.player.inCar
    });
  }

  entities.sort((a,b) => b.forward - a.forward);
  for (const ent of entities){
    drawFirstPersonEntity(ent, horizon, groundY, focal);
  }

  drawFirstPersonHud(viewer, groundY);
  drawCrosshair();
  updatePointerHint();
}

function drawFirstPersonSky(horizon){
  const grad = ctx.createLinearGradient(0,0,0,horizon);
  grad.addColorStop(0,'#070d21');
  grad.addColorStop(0.45,'#322a63');
  grad.addColorStop(0.8,'#f77fdc');
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,width,horizon);
  ctx.fillStyle = '#ffdca1';
  ctx.beginPath();
  ctx.arc(width*0.15, horizon*0.4, 60, 0, Math.PI*2);
  ctx.fill();
}

function drawFirstPersonGround(horizon, groundY){
  const grad = ctx.createLinearGradient(0,horizon,width,height);
  grad.addColorStop(0,'#30213f');
  grad.addColorStop(0.6,'#f8d3c2');
  grad.addColorStop(1,'#fef1dd');
  ctx.fillStyle = grad;
  ctx.fillRect(0,horizon,width,height-horizon);

  ctx.fillStyle = '#26262b';
  ctx.beginPath();
  ctx.moveTo(width*0.2, groundY);
  ctx.lineTo(width*0.45, horizon+60);
  ctx.lineTo(width*0.55, horizon+60);
  ctx.lineTo(width*0.8, groundY);
  ctx.closePath();
  ctx.fill();

  ctx.strokeStyle = 'rgba(255,255,255,0.45)';
  ctx.lineWidth = 2;
  ctx.setLineDash([12,14]);
  ctx.beginPath();
  ctx.moveTo(width/2, horizon+60);
  ctx.lineTo(width/2, groundY);
  ctx.stroke();
  ctx.setLineDash([]);
}

function drawFirstPersonEntity(ent, horizon, groundY, focal){
  const scale = focal / ent.forward;
  const screenX = width/2 + ent.side * scale;
  const screenWidth = clamp(ent.width * scale, 4, width*1.5);
  const screenHeight = clamp(ent.height * scale, 4, height*1.2);
  const baseY = groundY;
  const topY = baseY - screenHeight;

  if (ent.type === 'building'){
    const shade = clamp(1 - ent.forward / 2200, 0.2, 1);
    const color = shadeColor(ent.baseColor, shade);
    ctx.fillStyle = color;
    ctx.fillRect(screenX - screenWidth/2, topY, screenWidth, screenHeight);
    ctx.fillStyle = shadeColor(ent.accent, shade*0.8);
    ctx.fillRect(screenX - screenWidth/2, topY - screenHeight*0.05, screenWidth, screenHeight*0.05);
  } else if (ent.type === 'car'){
    ctx.fillStyle = ent.color;
    ctx.fillRect(screenX - screenWidth/2, topY + screenHeight*0.6, screenWidth, screenHeight*0.4);
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(screenX - screenWidth/2, topY + screenHeight*0.92, screenWidth, screenHeight*0.08);
    if (ent.isPlayer){
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 2;
      ctx.strokeRect(screenX - screenWidth/2, topY + screenHeight*0.6, screenWidth, screenHeight*0.4);
    }
  } else if (ent.type === 'palm'){
    ctx.fillStyle = '#0b0f12';
    ctx.fillRect(screenX-2, topY, 4, screenHeight);
    ctx.fillStyle = '#124736';
    ctx.beginPath();
    ctx.ellipse(screenX, topY, screenWidth*1.6, screenHeight*0.2, 0, 0, Math.PI*2);
    ctx.fill();
  }
}

function shadeColor(hex, factor){
  const rgb = hexColorToRgb(hex);
  const r = clamp(Math.round(rgb.r * factor + 255*(1-factor)*0.05), 0, 255);
  const g = clamp(Math.round(rgb.g * factor + 255*(1-factor)*0.05), 0, 255);
  const b = clamp(Math.round(rgb.b * factor + 255*(1-factor)*0.05), 0, 255);
  return `rgb(${r},${g},${b})`;
}
function hexColorToRgb(hex){
  const clean = hex.replace('#','');
  const num = parseInt(clean, 16);
  if (clean.length === 3){
    return {
      r: ((num >> 8) & 0xf) * 17,
      g: ((num >> 4) & 0xf) * 17,
      b: (num & 0xf) * 17
    };
  }
  return {
    r: (num >> 16) & 255,
    g: (num >> 8) & 255,
    b: num & 255
  };
}

function drawFirstPersonHud(viewer, groundY){
  const speed = viewer instanceof Car
    ? Math.abs(viewer.speed) * 0.05
    : world.player.currentSpeed * 0.05;
  ctx.fillStyle = 'rgba(0,0,0,0.35)';
  ctx.fillRect(30, height-90, 200, 60);
  ctx.fillStyle = '#fff';
  ctx.font = '20px "Segoe UI", sans-serif';
  ctx.fillText(`${speed.toFixed(0)} mph`, 44, height-56);
  ctx.font = '12px "Segoe UI", sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.7)';
  ctx.fillText(viewer instanceof Car ? 'Drive mode' : 'On foot', 44, height-34);

  if (viewer instanceof Car){
    ctx.fillStyle = 'rgba(255,255,255,0.35)';
    ctx.fillRect(width-220, height-90, 180, 60);
    ctx.fillStyle = '#fff';
    ctx.font = '13px "Segoe UI", sans-serif';
    ctx.fillText('E: exit vehicle', width-200, height-56);
    ctx.fillText('RT / W: accelerate', width-200, height-38);
  } else {
    ctx.fillStyle = 'rgba(255,255,255,0.35)';
    ctx.fillRect(width-220, height-90, 180, 60);
    ctx.fillStyle = '#fff';
    ctx.font = '13px "Segoe UI", sans-serif';
    ctx.fillText('E: interact', width-200, height-56);
    ctx.fillText('Hold mouse / right stick to look', width-200, height-38);
  }
}

function drawCrosshair(){
  ctx.strokeStyle = 'rgba(255,255,255,0.8)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(width/2 - 10, height/2);
  ctx.lineTo(width/2 + 10, height/2);
  ctx.moveTo(width/2, height/2 - 10);
  ctx.lineTo(width/2, height/2 + 10);
  ctx.stroke();
}

/* -----------------------
   minimap overlay
----------------------- */
function drawMinimap(){
  const mw = 200, mh = 130;
  ctx.save();
  ctx.translate(width - mw - 18, 18);
  ctx.fillStyle = 'rgba(0,0,0,0.45)';
  roundRect(ctx, 0,0,mw,mh,10,true,false);
  ctx.fillStyle = '#1f2b38';
  ctx.fillRect(8,8,mw-16,mh-16);

  const sw = mw-16;
  const sh = mh-16;
  const toMap = (wx, wy) => ({
    x: (wx / world.mapSize.w) * sw + 8,
    y: (wy / world.mapSize.h) * sh + 8
  });

  ctx.fillStyle = '#ff72c8';
  for (const road of world.roads){
    const start = toMap(road.x, road.y);
    const size = {
      w: road.w / world.mapSize.w * sw,
      h: road.h / world.mapSize.h * sh
    };
    ctx.globalAlpha = 0.18;
    ctx.fillRect(start.x, start.y, size.w, size.h);
    ctx.globalAlpha = 1;
  }

  for (const car of world.cars){
    const p = toMap(car.x, car.y);
    ctx.fillStyle = car.color;
    ctx.fillRect(p.x-3, p.y-2, 6, 4);
  }

  const playerPos = toMap(world.player.x, world.player.y);
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(playerPos.x, playerPos.y, 5, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();
}

function roundRect(ctx,x,y,w,h,r,fill,stroke){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
  if (fill) ctx.fill();
  if (stroke) ctx.stroke();
}

/* -----------------------
   pointer hint visibility
----------------------- */
function updatePointerHint(){
  pointerHint.style.display = (viewMode === 'first' && !input.pointerLocked) ? 'block' : 'none';
}

/* -----------------------
   game loop
----------------------- */
let viewMode = 'third';
let lastTime = performance.now();
let fps = 0;
let interactHeld = false;

function mainLoop(ts){
  const dt = Math.min(0.05, (ts - lastTime) / 1000);
  lastTime = ts;

  pollGamepad();
  composeInput();

  if (input.toggleView){
    viewMode = (viewMode === 'third') ? 'first' : 'third';
    uiMode.textContent = 'view: ' + (viewMode === 'third' ? '3rd person' : '1st person');
    if (viewMode === 'third' && document.pointerLockElement === canvas){
      document.exitPointerLock();
    }
    input.toggleView = false;
  }

  if (input.interact){
    if (!interactHeld){
      tryEnterExit();
      interactHeld = true;
    }
  } else {
    interactHeld = false;
  }

  world.player.update(dt, input, viewMode);
  for (const car of world.cars) car.update(dt, input);

  if (viewMode === 'third'){
    updateCamera(dt);
  } else {
    const follow = world.player.inCar ? world.player.inCar : world.player;
    world.camera.x = follow.x;
    world.camera.y = follow.y;
  }

  renderScene();

  fps = Math.round(1/dt);
  fpsLabel.textContent = fps + ' fps';

  input.lookDeltaX = 0;

  window.requestAnimationFrame(mainLoop);
}

/* -----------------------
   reset & init
----------------------- */
function resetWorld(){
  if (document.pointerLockElement === canvas) document.exitPointerLock();
  enterHouseDiv.style.display = 'none';
  createDemoWorld();
}
resetBtn.addEventListener('click', resetWorld);
closeHouseBtn.addEventListener('click', closeHouse);

/* -----------------------
   responsive canvas
----------------------- */
function fitCanvas(){
  const maxW = window.innerWidth - 40;
  const maxH = window.innerHeight - 40;
  const scale = Math.min(maxW / width, maxH / height);
  canvas.style.width = `${width * scale}px`;
  canvas.style.height = `${height * scale}px`;
}
window.addEventListener('resize', fitCanvas);
fitCanvas();

/* -----------------------
   boot
----------------------- */
createDemoWorld();
window.requestAnimationFrame(mainLoop);
updatePointerHint();

/* -----------------------
   end of script
----------------------- */
</script>
</body>
</html>